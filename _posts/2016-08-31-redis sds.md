---
layout: default
title: redis sds 
description: redis哨兵是其高可用性的解决方案，介绍哨兵。
categories: [redis]
tags: [redis, sds]
---

# redis sds（未完待续）

高级语言都有强大的字符串处理函数，平时经常用也没怎么太在意，等到使用c语言了之后才怀念起java、pyhon字符串处理函数的方便。
redis有个很棒的sds，sds全称“simple dynamic string”简单的动态字符串，它解决了c语言处理字符串的几个大问题：
 
 1. 隐藏字符串长度变化操作的细节，优化字符串操作的性能。
 1. 使字符串的操作更为安全。 
 1. 二进制安全。 
 
除了上述优点，sds还兼容部分c字符串处理函数。

首先我们来看看sds的定义：

```c
//sds.h 41行
struct sdshdr {
    unsigned int len;
    unsigned int free;
    char buf[];
};
```
非常简洁，len就是当前字符串的长度；free是为这个字符串申请的空间还剩下多少没有用完；buf则是我们存放在其中的字符串数据。
看到free，我们能猜到sds有减少空间分配的意图，频繁的内存申请、释放会导致性能下降，所以sds一开始就会申请出一片可能我们够用的空间，让我们使用，如果后续字符串要扩容那么按照一定的规律再增加空间；字符串缩小了之后采用“惰性释放”的方式来释放，对于redis这种对内存数据库而言.内存是弥足珍贵的资源，sds又该采用什么样的内存增长策略呢？
先看它创建的代码逻辑：

```c
//sds.c 51行
/*
	sds 类型定义在sds.h 39行:
	typedef char *sds; //是个字符串指针
*/
sds sdsnewlen(const void *init, size_t initlen) {
    struct sdshdr *sh;
	 //init是传入的字符串
	 //sds初始化所占用的空间是：传入的字符串长度（加1是字符串哨兵标记\0结尾）加上sdshdr结构体的大小
    if (init) {
        sh = zmalloc(sizeof(struct sdshdr)+initlen+1);
    } else {
        sh = zcalloc(sizeof(struct sdshdr)+initlen+1);
    }
    if (sh == NULL) return NULL;
    sh->len = initlen; //记录字符串的长度
    sh->free = 0; //初始化不并不多申请空间，所以free为0
    if (initlen && init)
        memcpy(sh->buf, init, initlen); //把字符串复制到sds的buf中
    sh->buf[initlen] = '\0'; //＋1的空间是为了存放字符串哨兵标记
    return (char*)sh->buf; //返回sds结构体中的buf
}
```

各位观众，sds玩的最6的技巧就在于此了！
我们创建sdshdr结构体，拿到的却是一个char指针，这个char指针是能适用c的所有标准字符串库的（但不是所有的我们都会用，后续有解释），也就是说可以使用诸如strcmp等等函数。
先别扯远，创建sdshdr结构体，拿到的却是一个char指针，那么sdshdr结构体怎么办？
先找个简单的sds的操作函数来看看：

```c
//sds.c 116行
void sdsclear(sds s) {
    struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr)));
    sh->free += sh->len;
    sh->len = 0;
    sh->buf[0] = '\0';
}
```
这个函数是sds清空的函数（不是free释放内存！只是清空老数据，该sds还将继续使用），相信大家一眼就看出门道所在：
我们创建的sdshdr结构体，拿到的是个char指针，但在sds的操作函数中，我们又能“找回”这个字符串所对应的sdshdr结构体。
精华就在这一句：

```c
	/*
		字符串指针往前移动一个sdshdr结构体大小的偏移量，就得到了指向了sdshdr结构体的地址。
		通过这样子的技巧我们就实现了“隐藏结构体的”的手段
	*/
	struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr)));
```
这招非常巧妙，在我们实现复杂容器的时候也能用到：将结构体中的“值数据”对外公开，但不将结构体直接公开，可以封装细节。
这里有一点还需要说明：sdshdr中字符串的指针是char buf[]（等价于 char buf[0]），在结构体中可以将其作为字符串指针使用，但在sizeof计算结构体空间时并没有将其算入！在malloc的时候要手动还要加上字符串数组的长度！
所以在通过偏移量拿到sdshdr结构体地址时可以直接减去sizeof(struct sdshdr)；
但如果sds使用的是char *的话，那就还要考虑偏移时不算指针占用的大小，还有字节对齐问题，有点麻烦。

明白了sds封装的技巧和为什么它能兼容部分c字符串库了之后我再来解释它的其它优点。

### 二进制安全

众所周知，c语言中字符串的结束标记位为"\0"，如果使用字节流传递二进制的图片等数据，那么就绝对不能使用strlen的函数来获取二进制数据的长度，但sds的设计是二进制安全的，这样sds就能储存任何数据。
就拿这个strlen获取长度来举例把，首先redis的协议中就要求传递数据表明自己的长度：

```
SET命令:
    set name joel
	客户端实际传递给服务器的数据如下：
        *3\r\n         		//参数的数量
	$3\r\n			//第一个参数“set”的长度
        set			//第一个参数
        $4\r\n			//第二个参数的长度
        name			//第二个参数：key
	$4\r\n			//第三个参数的长度
	joel			//第三个参数：value
```
redis按照长度接收了数据之后可以存在sds中，以后每次获取长度就直接读取sdshdr中的len，复杂度O(1),不会被“\0”所干扰。
如果不使用sds，也不使用额外的变量来储存客户度传来的长度，那么单纯的使用strlen将无法正确获取二进制数据的长度。（只能通过文件的文件头中数据才能获知文件信息）

### 使字符串的操作更为安全
sds按道理来说是能支持所有的c字符串操作的，但也不可滥用，比如会修改字符串内容的操作就必须使用sds提供的操作来完成！“读”操作那就随意了，比如strcmp、printf（仅仅只适用于字符串，不适用于二进制文件）。
使用c字符串函数来修改sds字符串内容，这个在语言级别无法干预，这算是sds的一个缺点吧，因为如果这么做了，轻则导致sds毫无意义（比如使用strlen来获取sds长度，二进制安全的特性就不存在了，而且O(1)的复杂度也将不能保证）；重则不当的free将导致内存溢出（仅仅释放掉buf，导致sdshdr没有被释放）。
这里提到的“安全”是指：“给c字符串操作函数的不安全版本提供一个安全、方便的解决方法” 。
例如strcat(d, s) 它不会做安全检查：它认为使用者能保证d指向的连续空间能完整的附加上s，所以这个函数将可能导致溢出；
而如果是用sds的cat操作则不会有问题：

```c
//sds.c 239行
//sds的拼接函数
sds sdscatlen(sds s, const void *t, size_t len) {
    struct sdshdr *sh;
    size_t curlen = sdslen(s);

    s = sdsMakeRoomFor(s,len); //长度不够，则扩容
    if (s == NULL) return NULL;
    sh = (void*) (s-(sizeof(struct sdshdr)));
    memcpy(s+curlen, t, len);
    sh->len = curlen+len;
    sh->free = sh->free-len;
    s[curlen+len] = '\0';
    return s;
}

sds sdscat(sds s, const char *t) {
    return sdscatlen(s, t, strlen(t));
}
```

### 隐藏字符串长度变化操作的细节，优化字符串操作的性能
sds在修改字符串时候，会动态调整空间占用，采用惰性释放多余的空间，这样能减少空间的申请、释放频率，达到提高效率的效果。

